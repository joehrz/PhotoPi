import numpy as np
import open3d as o3d
import logging
import copy
from scipy.ndimage import gaussian_filter1d
import matplotlib.pyplot as plt
import networkx as nx
from sklearn.decomposition import PCA
import math
from sklearn.cluster import DBSCAN
from sklearn.neighbors import NearestNeighbors
from sklearn.linear_model import LinearRegression

logger = logging.getLogger(__name__)
logging.basicConfig(level=logging.INFO)

    

class MainStemSegmentation:
    """
    MainStemSegmentation: A class to segment the main stem from a full plant point cloud using graph‐based methods.

    This class implements a robust pipeline for extracting the main stem (i.e., the primary vertical growth 
    axis) from a 3D plant point cloud, such as those generated by photogrammetry of wheat. The main stem is 
    used as a reference structure for subsequent morphological analyses (for example, leaf angle computation) 
    because it represents the primary growth direction and provides a stable axis from which lateral organ 
    orientations can be measured.

    The segmentation process proceeds through the following steps:

      1. Preprocessing:
         - The input point cloud is centered in the XY-plane.
         - The cloud is sliced horizontally into a configurable number of sections based on the z-coordinate.
         - In each section, DBSCAN clustering is applied to group points into clusters representing distinct 
           plant regions (e.g., parts of the stem or leaves).

      2. Centroid Aggregation and Graph Construction:
         - Cluster centroids from the continuous structures (detected across slices) are aggregated into a 
           reduced point cloud.
         - A k-Nearest Neighbor (k-NN) graph is built from these centroids, linking clusters across adjacent 
           slices based on spatial proximity.
         - Cycles in the graph are removed to yield a tree-like structure that reflects the hierarchical 
           organization of the plant.

      3. Node Classification:
         - Global Principal Component Analysis (PCA) is used on the aggregated centroids to determine the 
           principal growth axis.
         - Nodes near this principal axis are classified as 'stem', while others are classified as 'leaf' 
           (or 'branch_or_leaf').
         - Nodes with high connectivity (e.g., degree >= a specified threshold) are further labeled as 
           'branch_off' nodes, which are candidate sites where branches (and hence leaves) depart from the main stem.

      4. Main Stem Extraction:
         - A custom graph traversal algorithm (leveraging a cost function that penalizes lateral deviations 
           and favors upward movement) extracts a continuous path from the base (lowest z-value) to the top 
           (highest z-value) of the plant, representing the main stem.
         - This extracted main stem centerline provides a robust, automated reference that captures the 
           natural vertical growth pattern of the plant.

      5. Output and Use:
         - The class stores key outputs such as the segmented graph, the main stem path, the branch_off 
           (anchor) nodes, and local sections of the main stem (up and down) as well as branch (leaf) regions.
         - These outputs form the basis for further analyses. For example, the extracted main stem and branch 
           sections are used by a separate module to compute leaf angles relative to the primary growth axis.

    Usage Example:
         # Create an instance of the segmentation class with a point cloud.
         segmentation = MainStemSegmentation(point_cloud)
         segmentation.process_point_cloud(eps=0.006, min_samples=50, n_sections=80)
         segmentation.aggregate_centroids()
         segmentation.build_graph(k=2)
         segmentation.remove_cycles()
         segmentation.segment_nodes()
         segmentation.label_branch_off_nodes(min_degree=3)
         segmentation.bridge_graph_gap(max_gap=0.1)
         main_stem_path = segmentation.traverse_main_stem(alpha=1.0, theta_threshold=math.pi/8)
         segmentation.visualize_centerline()
         segmentation.reclassify_nodes_by_centerline(distance_threshold=0.005)
         segmentation.extract_sections(n_main_stem=5, n_leaf=5)

    Note:
         This class focuses exclusively on segmenting the main stem and building the corresponding graph network.
         The extracted main stem is critical as a reference for measuring the orientation of lateral organs 
         (leaf angles), which are computed in a separate module/class.
    """
    def __init__(self, point_cloud):
        """
        Initialize with a full plant point cloud.
        Here, center the point cloud in the XY-plane.
        """
        self.original_pcd = point_cloud
        self.pcd = copy.deepcopy(point_cloud)
        
        
        # Variables for graph-based segmentation.
        self.sections = []         # Slices of the point cloud.
        self.sections_analysis = []  # Cluster analysis results for each slice.
        self.graph_structure = {}  # Adjacency between clusters (nodes) in consecutive slices.
        self.continuous_structures = []  # List of continuous vertical structures.
        
        # Aggregated centroid cloud and final graph.
        self.centroids_pcd = o3d.geometry.PointCloud()
        self.graph = nx.Graph()
        
        # Final main stem segmentation results.
        self.main_stem_structure = None   # The chosen continuous structure (list of (slice, cluster) tuples)
        self.centerline = []              # 3D points along the main stem (via sliding ring)

        # Node sets, BFS results
        self.branch_off_nodes = []
        self.all_main_stem_points_up = []
        self.all_main_stem_points_down = []
        self.all_leaf_points = []


    # ----------------------------------------------------------------
    # 1) Preprocessing: Slicing the point cloud & clustering (DBSCAN)
    # ----------------------------------------------------------------
    def process_point_cloud(self, eps=0.006, min_samples=50, n_sections=80):
        """
        Slices the point cloud horizontally and clusters each slice using DBSCAN.
        """
        # Center the cloud in the XY-plane.
        pts = np.asarray(self.pcd.points)
        xy_mean = np.mean(pts[:, :2], axis=0)
        pts[:, :2] -= xy_mean  # shift x and y so that the cloud is centered
        self.pcd.points = o3d.utility.Vector3dVector(pts)
        logger.info(f"Point cloud centered in XY with mean: {xy_mean}")

        self.points = np.asarray(self.pcd.points)
        # Compute normals if not present.
        if not self.pcd.has_normals():
            # Using a fixed radius (adjust if needed based on your data scale)
            self.pcd.estimate_normals(
                o3d.geometry.KDTreeSearchParamHybrid(radius=0.005 * 2, max_nn=30)
            )
            self.pcd.normalize_normals()
        
        self.normals = np.asarray(self.pcd.normals)
        logger.info("process_point_cloud: Slicing & clustering")
        self.sections = self._split_points_into_sections(self.points, n_sections)
        self.sections_analysis = self._analyze_dbscan_results_3d(self.sections, eps=eps, min_samples=min_samples)
        self.graph_structure = self._construct_graph_with_branching(self.sections_analysis, eps=0.05)
        self.continuous_structures = self._find_continuous_structures(self.graph_structure)
        logger.info(f"Found {len(self.continuous_structures)} continuous structures across slices.")

    def _split_points_into_sections(self, points, n_sections):
        z = points[:, 2]
        min_z, max_z = np.min(z), np.max(z)
        thresholds = np.linspace(min_z, max_z, n_sections + 1)
        all_sections = []
        for i in range(n_sections):
            mask = (z > thresholds[i]) & (z <= thresholds[i+1])
            all_sections.append(points[mask])
        return all_sections

    def _analyze_dbscan_results_3d(self, sections, eps=0.006, min_samples=50):
        output = []
        for i, sec in enumerate(sections):
            if len(sec) < 1:
                output.append({'section_index': i, 'clusters': [], 'count': 0})
                continue
            db = DBSCAN(eps=eps, min_samples=min_samples).fit(sec)
            labels = db.labels_
            unique_labels = set(labels)
            sec_data = []
            for lbl in unique_labels:
                if lbl == -1:
                    continue  # Skip noise.
                mask = (labels == lbl)
                cluster_pts = sec[mask]
                centroid = np.mean(cluster_pts, axis=0)
                radius = np.max(np.linalg.norm(cluster_pts - centroid, axis=1))
                sec_data.append({
                    'centroid': centroid,
                    'radius': radius,
                    'points': cluster_pts
                })
            output.append({
                'section_index': i,
                'clusters': sec_data,
                'count': len(sec_data)
            })
        return output

    def _construct_graph_with_branching(self, sections_analysis, eps=0.05):
        """
        For each slice i, link each cluster to clusters in slice i+1 if their centroids are within eps distance.
        Returns an adjacency dictionary.
        """
        graph = {}
        n_slices = len(sections_analysis)
        for i in range(n_slices - 1):
            cur_clusters = sections_analysis[i]['clusters']
            nxt_clusters = sections_analysis[i + 1]['clusters']
            for j, ccl in enumerate(cur_clusters):
                c_centroid = ccl['centroid']
                connections = []
                for k, ncl in enumerate(nxt_clusters):
                    n_centroid = ncl['centroid']
                    dist = np.linalg.norm(c_centroid - n_centroid)
                    if dist < eps:
                        connections.append((i + 1, k))
                if connections:
                    graph[(i, j)] = connections
        return graph

    def _find_continuous_structures(self, graph):
        """
        Traverse the adjacency graph to find continuous structures (as lists of (slice, cluster) tuples).
        """
        visited = set()
        structures = []

        def dfs(node, struct):
            if node in visited:
                return
            visited.add(node)
            struct.append(node)
            for neigh in graph.get(node, []):
                dfs(neigh, struct)

        for node in graph:
            if node not in visited:
                st = []
                dfs(node, st)
                if st:
                    structures.append(st)
        return structures


    # ---------------------------------------------------
    # 2) Aggregation of Cluster Centroids and Graph Build
    # ---------------------------------------------------
    def aggregate_centroids(self):
        """
        For each continuous structure, compute the aggregated centroids.
        These centroids become nodes in the final graph.
        """
        logger.info("aggregate_centroids: Aggregating centroids from continuous structures.")
        aggregated_centroids = []
        for structure in self.continuous_structures:
            ctds = self._aggregate_structure_centroids(self.sections_analysis, structure)
            aggregated_centroids.append(ctds)

        all_pts = []
        colors = []
        for ctds in aggregated_centroids:
            all_pts.extend(ctds)
            # Assign a random color per structure (for visualization).
            rand_c = np.random.rand(3)
            colors.extend([rand_c] * len(ctds))

        self.centroids_pcd.points = o3d.utility.Vector3dVector(np.array(all_pts))
        self.centroids_pcd.colors = o3d.utility.Vector3dVector(np.array(colors))
        logger.info(f"Aggregated {len(all_pts)} centroids into centroids_pcd.")

    def _aggregate_structure_centroids(self, sections_analysis, structure):
        ctds = []
        for (sec_i, cls_j) in structure:
            cluster = sections_analysis[sec_i]['clusters'][cls_j]
            ctds.append(cluster['centroid'])
        return ctds

    def build_graph(self, k=2):
        """
        Build a k-NN graph (using NetworkX) from the aggregated centroids.
        """
        logger.info(f"build_graph: Building k-NN graph with k={k}")
        cpts = np.asarray(self.centroids_pcd.points)
        for idx, pt in enumerate(cpts):
            self.graph.add_node(idx, pos=pt)
        nbrs = NearestNeighbors(n_neighbors=k+1).fit(cpts)
        dist, inds = nbrs.kneighbors(cpts)
        for i in range(len(cpts)):
            for j in range(1, k+1):
                self.graph.add_edge(i, inds[i][j], weight=dist[i][j])
        logger.info(f"Graph built with {self.graph.number_of_nodes()} nodes and {self.graph.number_of_edges()} edges.")

    def remove_cycles(self):
        """
        Remove cycles by identifying cycles and removing the largest edge in each cycle.
        This helps to avoid loops in the subsequent traversal.
        """
        logger.info("remove_cycles: Removing cycles from the graph.")
        cycles = nx.cycle_basis(self.graph)
        for cyc in cycles:
            max_edge = None
            max_w = -1e9
            for i in range(len(cyc)):
                e = (cyc[i], cyc[(i + 1) % len(cyc)])
                w = self.graph[e[0]][e[1]]['weight']
                if w > max_w:
                    max_w = w
                    max_edge = e
            if max_edge:
                self.graph.remove_edge(*max_edge)
        logger.info("Cycles removed.")




    # ---------------------------------------------------
    # 3) Initial Node Classification (PCA & Branch-Off)
    # ---------------------------------------------------
    def segment_nodes(self):
        """
        Use global PCA on the centroid cloud to classify nodes:
         - Nodes close to the principal axis are classified as 'stem'
         - Others are 'branch_or_leaf'
        """
        cpts = np.asarray(self.centroids_pcd.points)
        if len(cpts) < 2:
            logger.warning("segment_nodes: Not enough centroids for PCA.")
            return
        pca = PCA(n_components=3)
        pca.fit(cpts)
        axis = pca.components_[0]
        proj = cpts @ axis
        # Compute distance from the principal axis.
        dist = np.linalg.norm(cpts - np.outer(proj, axis), axis=1)
        thr = np.percentile(dist, 80)  # Threshold for classification.
        for i, nd in enumerate(self.graph.nodes()):
            if dist[i] < thr:
                self.graph.nodes[nd]['type'] = 'stem'
            else:
                self.graph.nodes[nd]['type'] = 'leaf'
        logger.info("segment_nodes: PCA-based classification complete.")

    def label_branch_off_nodes(self, min_degree=3):
        """
        Label nodes with degree >= min_degree as 'branch_off'.
        """
        logger.info(f"label_branch_off_nodes: Labeling nodes with degree >= {min_degree} as branch_off.")
        self.branch_off_nodes.clear()
        for n in self.graph.nodes():
            if self.graph.degree(n) >= min_degree:
                self.graph.nodes[n]['type'] = 'branch_off'
        self.branch_off_nodes = [n for n in self.graph.nodes() if self.graph.nodes[n].get('type') == 'branch_off']
        logger.info(f"Found {len(self.branch_off_nodes)} branch_off nodes.")



    # ---------------------------------------------------------
    # 4) Graph Traversal for Main Stem Extraction
    # ---------------------------------------------------------
    def compute_edge_cost(self, current_node, next_node, reference_direction=np.array([0, 0, 1]),
                          alpha=1.0, theta_threshold=math.pi/8):
        """
        Compute cost for traversing from current_node to next_node.
        Cost is based on Euclidean distance plus an angular penalty for deviating from reference_direction.
        """
        pos_current = self.graph.nodes[current_node]['pos']
        pos_next = self.graph.nodes[next_node]['pos']
        vec = pos_next - pos_current
        d = np.linalg.norm(vec)
        if d == 0:
            return 0
        v_local = vec / d
        # Angle between local vector and reference direction.
        dot_val = np.clip(np.dot(v_local, reference_direction), -1.0, 1.0)
        theta = np.arccos(dot_val)
        penalty = alpha * (theta / theta_threshold)
        cost = d * (1 + penalty)
        return cost

    def traverse_main_stem(self, alpha=1.0, theta_threshold=math.pi/8):
        """
        Traverse the centroid graph using Dijkstra's algorithm and the custom cost function to extract the main stem.
        The base (lowest z) and top (highest z) nodes are automatically identified.
        """
        # Identify base and top nodes based on z-coordinate.
        nodes = list(self.graph.nodes())
        positions = np.array([self.graph.nodes[n]['pos'] for n in nodes])
        z_coords = positions[:, 2]
        base_node = nodes[np.argmin(z_coords)]
        top_node = nodes[np.argmax(z_coords)]
        logger.info(f"traverse_main_stem: Base node {base_node} (z={np.min(z_coords):.3f}), Top node {top_node} (z={np.max(z_coords):.3f})")
        
        # Build a directed weighted graph using our custom cost function.
        G_weighted = nx.DiGraph()
        for n in self.graph.nodes():
            G_weighted.add_node(n, pos=self.graph.nodes[n]['pos'])
        for (u, v) in self.graph.edges():
            cost_uv = self.compute_edge_cost(u, v, reference_direction=np.array([0, 0, 1]), 
                                               alpha=alpha, theta_threshold=theta_threshold)
            cost_vu = self.compute_edge_cost(v, u, reference_direction=np.array([0, 0, 1]), 
                                               alpha=alpha, theta_threshold=theta_threshold)
            G_weighted.add_edge(u, v, weight=cost_uv)
            G_weighted.add_edge(v, u, weight=cost_vu)
        
        # Compute shortest paths from the base node.
        lengths, paths = nx.single_source_dijkstra(G_weighted, base_node)
        
        if top_node not in paths:
            logger.warning("traverse_main_stem: Top node not reachable from base node.")
            return []
        
        self.main_stem_path = paths[top_node]
        logger.info(f"Main stem path (node indices): {self.main_stem_path}")
        return self.main_stem_path



    def reclassify_nodes_by_centerline(self, distance_threshold=0.005):
        """
        Reclassify nodes based on their distance to the main stem centerline.
    
        Parameters:
            distance_threshold (float): Maximum distance from the centerline for a node to be considered part of the stem.
        """
        if not self.main_stem_path:
            logger.warning("No main stem path found. Run traverse_main_stem() first.")
            return

        # Compute the centerline points from the main stem path.
        centerline_pts = np.array([self.graph.nodes[n]['pos'] for n in self.main_stem_path])
    
            # A helper function to compute the minimum distance from a point to the centerline.
        def min_distance_to_centerline(pt, centerline):
            # Compute distance from pt to each segment along the centerline.
            # For simplicity, we compute the distance to every centerline point.
            dists = np.linalg.norm(centerline - pt, axis=1)
            return np.min(dists)
    
        # Reclassify each node in the centroid graph.
        for n in self.graph.nodes():
            node_pos = self.graph.nodes[n]['pos']
            dist = min_distance_to_centerline(node_pos, centerline_pts)
            if dist <= distance_threshold:
                self.graph.nodes[n]['type'] = 'stem'
            else:
                self.graph.nodes[n]['type'] = 'leaf'
    
        logger.info("Reclassification by centerline completed.")


    def bridge_graph_gap(self, max_gap=0.02):
        """
        Check if there are disconnected subgraphs in the centroid graph.
        If the distance between the closest nodes of two subgraphs is below max_gap,
        add an edge to bridge them.
        """
        components = list(nx.connected_components(self.graph))
        if len(components) <= 1:
            logger.info("bridge_graph_gap: Graph is fully connected.")
            return

        logger.info(f"bridge_graph_gap: Found {len(components)} disconnected components. Attempting to bridge...")
    
        # Get a list of components (each is a set of node indices)
        # Here we will try to connect the largest component (presumably the main stem) with others.
        components.sort(key=lambda comp: len(comp), reverse=True)
        main_comp = components[0]
    
        for comp in components[1:]:
            min_dist = float('inf')
            best_pair = None
            # Compare every node in the main component with every node in the disconnected component.
            for n1 in main_comp:
                for n2 in comp:
                    pos1 = np.array(self.graph.nodes[n1]['pos'])
                    pos2 = np.array(self.graph.nodes[n2]['pos'])
                    dist = np.linalg.norm(pos1 - pos2)
                    if dist < max_gap and dist < min_dist:
                        min_dist = dist
                        best_pair = (n1, n2)
        
            if best_pair and min_dist < max_gap:
                self.graph.add_edge(best_pair[0], best_pair[1], weight=min_dist)
                logger.info(f"Bridged gap between nodes {best_pair[0]} and {best_pair[1]} with distance {min_dist:.4f}")
            else:
                logger.warning(f"bridge_graph_gap: No pair found within gap threshold {max_gap}")


    def extract_sections(self, n_main_stem=5, n_leaf=5):
        """
        BFS from each branch_off => up/down stem => leaf. 
        """
        logger.info("extract_sections => BFS for each branch_off node.")
        for b_off in self.branch_off_nodes:
            neighbors = list(self.graph.neighbors(b_off))
            stem_ns = [n for n in neighbors if self.graph.nodes[n].get('type') == 'stem']
            leaf_ns = [n for n in neighbors if self.graph.nodes[n].get('type') == 'leaf']

            if len(stem_ns) != 2 or len(leaf_ns) != 1:
                logger.warning(f"Branch-off node {b_off} => expected 2 'stem' neighbors + 1 'branch_or_leaf'.")
                continue

            up_nodes = self._traverse_stem(stem_ns[0], b_off, n_main_stem)
            down_nodes = self._traverse_stem(stem_ns[1], b_off, n_main_stem)
            lf_nodes = self._traverse_leaf(leaf_ns[0], b_off, n_leaf)

            up_pts = [self.graph.nodes[x]['pos'] for x in up_nodes]
            down_pts = [self.graph.nodes[x]['pos'] for x in down_nodes]
            leaf_pts = [self.graph.nodes[x]['pos'] for x in lf_nodes]

            self.all_main_stem_points_up.append(np.array(up_pts))
            self.all_main_stem_points_down.append(np.array(down_pts))
            self.all_leaf_points.append(np.array(leaf_pts))

            logger.info(f"Branch-off node {b_off}: up stem points = {len(up_pts)}, down stem points = {len(down_pts)}, leaf points = {len(leaf_pts)}")



    def label_branch_off_nodes(self, min_degree=3):
        """
        Label nodes with degree >= min_degree as 'branch_off'.

        Parameters:
        min_degree (int): The minimum degree required for a node to be considered a branch-off.
        """
        logger.info(f"label_branch_off_nodes => labeling nodes with degree >= {min_degree} as 'branch_off'.")
        self.branch_off_nodes.clear()
        for n in self.graph.nodes():
            deg = self.graph.degree(n)
            if deg >= min_degree:
                self.graph.nodes[n]['type'] = 'branch_off'
        self.branch_off_nodes = [x for x in self.graph.nodes() if self.graph.nodes[x].get('type') == 'branch_off']
        logger.info(f"Found {len(self.branch_off_nodes)} branch_off nodes (deg >= {min_degree}).")



    



    # ---------------------------------------------------
    # 5) Visualization Methods
    # ---------------------------------------------------



    def visualize_centerline(self):
        """
        Visualize the extracted main stem as a red centerline over the original point cloud.
        """
        if not self.main_stem_path:
            logger.warning("visualize_centerline: No main stem path to visualize.")
            return
        centerline_pts = np.array([self.graph.nodes[n]['pos'] for n in self.main_stem_path])
        lines = [[i, i + 1] for i in range(len(centerline_pts) - 1)]
        cl_ls = o3d.geometry.LineSet(
            points=o3d.utility.Vector3dVector(centerline_pts),
            lines=o3d.utility.Vector2iVector(lines)
        )
        cl_ls.colors = o3d.utility.Vector3dVector([[1, 0, 0] for _ in lines])
        o3d.visualization.draw_geometries([cl_ls], window_name="Main Stem Centerline")


    def visualize_graph_with_types(self, show_original=False):
        """
        Show the centroid graph color-coded by type:
          'stem'(red), 'branch_off'(blue), 'branch_or_leaf'(green).
        Edges in black. Optionally add the original cloud for context.
        """
        logger.info("visualize_graph_with_types => color-coded centroid graph.")
        geoms = []
        if show_original:
            geoms.append(self.point_cloud)

        pos = []
        type_colors = []
        for n in self.graph.nodes():
            p = self.graph.nodes[n]['pos']
            pos.append(p)
            t = self.graph.nodes[n].get('type', 'unknown')
            if t == 'stem':
                type_colors.append([1, 0, 0])  # red
            elif t == 'branch_off':
                type_colors.append([0, 0, 1])  # blue
            elif t == 'leaf':
                type_colors.append([0, 1, 0])  # green
            else:
                type_colors.append([0.5, 0.5, 0.5])
        pos = np.array(pos)

        # Node point cloud
        pcd_nodes = o3d.geometry.PointCloud()
        pcd_nodes.points = o3d.utility.Vector3dVector(pos)
        pcd_nodes.colors = o3d.utility.Vector3dVector(type_colors)
        geoms.append(pcd_nodes)

        # Edges => black lines
        edges = []
        for n in self.graph.nodes():
            for m in self.graph.neighbors(n):
                if m > n:
                    edges.append([n, m])
        ls = o3d.geometry.LineSet()
        ls.points = o3d.utility.Vector3dVector(pos)
        ls.lines = o3d.utility.Vector2iVector(np.array(edges))
        ls.colors = o3d.utility.Vector3dVector([[0, 0, 0]] * len(edges))
        geoms.append(ls)

        o3d.visualization.draw_geometries(geoms, window_name="Centroid Graph (Types)")



    # ------------------- HELPER METHODS  ------------------- #

    def _traverse_stem(self, start_node, branch_off_node, n_main_stem):
        visited = set([branch_off_node])
        result = []
        cur = start_node
        while cur is not None and len(result) < n_main_stem:
            if self.graph.nodes[cur].get('type') == 'stem':
                result.append(cur)
            visited.add(cur)
            neighs = [nn for nn in self.graph.neighbors(cur)
                      if nn not in visited and self.graph.nodes[nn].get('type') == 'stem']
            if len(neighs) > 0:
                cur = neighs[0]
            else:
                cur = None
        return result

    def _traverse_leaf(self, start_node, branch_off_node, n_leaf):
        visited = set([branch_off_node])
        result = []
        cur = start_node
        while cur is not None and len(result) < n_leaf:
            if self.graph.nodes[cur].get('type') == 'leaf':
                result.append(cur)
            visited.add(cur)
            neighs = [nn for nn in self.graph.neighbors(cur)
                      if nn not in visited and self.graph.nodes[nn].get('type') == 'leaf']
            if len(neighs) > 0:
                cur = neighs[0]
            else:
                cur = None
        return result